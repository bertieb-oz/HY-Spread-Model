"""
US High Yield Spread Rich/Cheap Model
======================================
A Streamlit web application that uses rolling multiple linear regression
to determine if US High Yield credit spreads are rich, cheap, or neutral
relative to fundamental market drivers.

Author: Generated by Claude
"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import io
from datetime import datetime

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Page config
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.set_page_config(
    page_title="HY Spread Rich/Cheap Model",
    page_icon="ğŸ“Š",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Custom CSS
st.markdown("""
<style>
    .signal-box {
        padding: 24px; border-radius: 12px; text-align: center;
        margin-bottom: 16px; color: white; font-weight: bold;
    }
    .signal-cheap { background: linear-gradient(135deg, #1b8a3d, #27ae60); }
    .signal-rich  { background: linear-gradient(135deg, #c0392b, #e74c3c); }
    .signal-neutral { background: linear-gradient(135deg, #636e72, #95a5a6); }
    .metric-card {
        background: #f8f9fa; border-radius: 8px; padding: 16px;
        border-left: 4px solid #3498db; margin-bottom: 8px;
    }
    div[data-testid="stSidebar"] { background-color: #f0f2f6; }
</style>
""", unsafe_allow_html=True)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Data loading & feature engineering
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EXPECTED_COLS = {
    "date": ["date"],
    "hy_spread": ["us high yield spread", "hy spread", "hy_spread", "high yield spread"],
    "vix": ["vix", "vix index"],
    "oil": ["oil", "oil price", "wti", "brent", "cl1 comdty"],
    "cdx": ["cdx", "cdx hy", "cdx hy 5y", "cdx hy cdsi gen 5y corp"],
    "move": ["move", "move index"],
    "spx": ["spx yield", "spx index", "spx", "s&p 500"],
    "hyg": ["hyg equity outstanding", "hyg shares", "hyg shares outstanding", "hyg"],
}


def _match_column(df_columns, aliases):
    """Fuzzy-match a DataFrame column against a list of aliases."""
    lower_cols = {}
    for c in df_columns:
        try:
            lower_cols[str(c).strip().lower()] = c
        except Exception:
            continue
    for alias in aliases:
        if alias in lower_cols:
            return lower_cols[alias]
    return None


def load_data(uploaded_file):
    """Load and validate the uploaded Excel file."""
    # Try multiple header configurations
    for skip in [0, 1, 2]:
        try:
            df = pd.read_excel(uploaded_file, header=skip)
            # Check if second row looks like Bloomberg tickers â€” skip it
            if df.iloc[0].astype(str).str.contains("Index|Comdty|Equity|Corp", case=False).any():
                df = df.iloc[1:].reset_index(drop=True)
            # Try to find a date column
            col_map = {}
            for key, aliases in EXPECTED_COLS.items():
                matched = _match_column(df.columns, aliases)
                if matched:
                    col_map[key] = matched
            if "date" in col_map and "hy_spread" in col_map:
                break
        except Exception:
            continue

    if "date" not in col_map or "hy_spread" not in col_map:
        st.error("âŒ Could not find required columns. Please ensure your file has a 'Date' column and a 'US High Yield Spread' column.")
        return None, None

    missing = [k for k in EXPECTED_COLS if k not in col_map]
    if missing:
        st.error(f"âŒ Missing columns: {missing}. Found: {list(col_map.keys())}")
        return None, None

    # Rename to standard names
    rename = {v: k for k, v in col_map.items()}
    df = df.rename(columns=rename)
    df = df[list(EXPECTED_COLS.keys())].copy()

    # Convert types
    df["date"] = pd.to_datetime(df["date"], errors="coerce")
    for c in ["hy_spread", "vix", "oil", "cdx", "move", "spx", "hyg"]:
        df[c] = pd.to_numeric(df[c], errors="coerce")

    df = df.dropna(subset=["date"]).sort_values("date").reset_index(drop=True)
    df = df.ffill()  # forward-fill minor gaps

    return df, col_map


def engineer_features(df):
    """Create derived features for regression."""
    feat = df[["date", "hy_spread"]].copy()

    # Levels
    feat["vix_level"] = df["vix"]
    feat["oil_level"] = df["oil"]
    feat["move_level"] = df["move"]
    feat["spx_level"] = df["spx"]

    # Month-over-month changes
    feat["vix_change"] = df["vix"].diff()
    feat["oil_change"] = df["oil"].diff()
    feat["cdx_change"] = df["cdx"].diff()
    feat["move_change"] = df["move"].diff()
    feat["spx_change"] = df["spx"].diff()
    feat["hyg_change"] = df["hyg"].diff()

    feat = feat.dropna().reset_index(drop=True)
    return feat


FEATURE_COLS = [
    "vix_level", "vix_change",
    "oil_level", "oil_change",
    "cdx_change",
    "move_level", "move_change",
    "spx_level", "spx_change",
    "hyg_change",
]

FEATURE_LABELS = {
    "vix_level": "VIX Level",
    "vix_change": "VIX Change",
    "oil_level": "Oil Level",
    "oil_change": "Oil Change",
    "cdx_change": "CDX Change",
    "move_level": "MOVE Level",
    "move_change": "MOVE Change",
    "spx_level": "SPX Level",
    "spx_change": "SPX Change",
    "hyg_change": "HYG Shares Change",
}


def run_regression(feat_df, lookback):
    """Run rolling-window OLS regression."""
    n = len(feat_df)
    if n < lookback + 1:
        st.error(f"Not enough data ({n} rows) for a {lookback}-month lookback window.")
        return None, None

    X_all = feat_df[FEATURE_COLS].values
    y_all = feat_df["hy_spread"].values

    predictions = np.full(n, np.nan)
    residuals = np.full(n, np.nan)
    coef_history = []

    for i in range(lookback, n):
        X_train = X_all[i - lookback:i]
        y_train = y_all[i - lookback:i]

        # Check for NaN in training window
        mask = ~(np.isnan(X_train).any(axis=1) | np.isnan(y_train))
        if mask.sum() < 20:
            continue

        model = LinearRegression()
        model.fit(X_train[mask], y_train[mask])
        pred = model.predict(X_all[i:i+1])[0]
        predictions[i] = pred
        residuals[i] = y_all[i] - pred
        coef_history.append({
            "idx": i,
            "date": feat_df["date"].iloc[i],
            "intercept": model.intercept_,
            **{f"coef_{c}": v for c, v in zip(FEATURE_COLS, model.coef_)},
        })

    results = feat_df.copy()
    results["predicted"] = predictions
    results["residual"] = residuals

    # Full-window final model statistics (last window)
    last_start = n - lookback
    X_last = X_all[last_start:n]
    y_last = y_all[last_start:n]
    mask = ~(np.isnan(X_last).any(axis=1) | np.isnan(y_last))
    final_model = LinearRegression()
    final_model.fit(X_last[mask], y_last[mask])

    y_pred_last = final_model.predict(X_last[mask])
    ss_res = np.sum((y_last[mask] - y_pred_last) ** 2)
    ss_tot = np.sum((y_last[mask] - y_last[mask].mean()) ** 2)
    r2 = 1 - ss_res / ss_tot
    n_obs = mask.sum()
    k = len(FEATURE_COLS)
    adj_r2 = 1 - (1 - r2) * (n_obs - 1) / (n_obs - k - 1)
    residual_std = np.sqrt(ss_res / (n_obs - k - 1))

    # Coefficient statistics
    X_m = X_last[mask]
    XtX_inv = np.linalg.pinv(X_m.T @ X_m)
    se = np.sqrt(np.diag(XtX_inv) * (residual_std ** 2))
    t_stats = final_model.coef_ / se
    from scipy import stats as sp_stats
    p_values = 2 * (1 - sp_stats.t.cdf(np.abs(t_stats), df=n_obs - k - 1))

    model_stats = {
        "r2": r2,
        "adj_r2": adj_r2,
        "n_obs": n_obs,
        "residual_std": residual_std,
        "coefficients": final_model.coef_,
        "intercept": final_model.intercept_,
        "std_errors": se,
        "t_stats": t_stats,
        "p_values": p_values,
    }

    coef_df = pd.DataFrame(coef_history)
    return results, model_stats, coef_df


def calculate_signals(results, cheap_thresh, rich_thresh):
    """Calculate z-scores and trading signals."""
    valid = results["residual"].dropna()
    mean_r = valid.mean()
    std_r = valid.std()

    results["z_score"] = (results["residual"] - mean_r) / std_r

    def _signal(z):
        if pd.isna(z):
            return "N/A"
        if z > cheap_thresh:
            return "CHEAP"
        if z < -rich_thresh:
            return "RICH"
        return "NEUTRAL"

    results["signal"] = results["z_score"].apply(_signal)
    return results


def monthly_attribution(results, coef_df):
    """Calculate factor-level contribution to predicted spread changes."""
    if coef_df is None or coef_df.empty or len(coef_df) < 2:
        return None
    last = coef_df.iloc[-1]
    prev = coef_df.iloc[-2]
    idx_last = int(last["idx"])
    idx_prev = int(prev["idx"])

    attrib_rows = []
    for col in FEATURE_COLS:
        coef_val = last[f"coef_{col}"]
        feat_change = results[col].iloc[idx_last] - results[col].iloc[idx_prev]
        contribution = coef_val * feat_change
        attrib_rows.append({
            "Factor": FEATURE_LABELS.get(col, col),
            "Coefficient": coef_val,
            "Feature Change": feat_change,
            "Contribution (spread, %)": contribution,
        })

    attrib = pd.DataFrame(attrib_rows)
    total = attrib["Contribution (spread, %)"].sum()
    attrib["% of Total"] = np.where(total != 0, attrib["Contribution (spread, %)"] / abs(total) * 100, 0)
    return attrib


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Charts
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def chart_actual_vs_predicted(results):
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=results["date"], y=results["hy_spread"],
                             name="Actual HY Spread", line=dict(color="#2980b9", width=2)))
    fig.add_trace(go.Scatter(x=results["date"], y=results["predicted"],
                             name="Predicted HY Spread", line=dict(color="#e67e22", width=2, dash="dash")))
    fig.update_layout(title="Actual vs Predicted HY Spreads",
                      xaxis_title="Date", yaxis_title="Spread (%)",
                      template="plotly_white", height=450, legend=dict(orientation="h", y=1.12))
    return fig


def chart_residuals(results, cheap_thresh, rich_thresh):
    valid = results.dropna(subset=["residual"])
    mean_r = valid["residual"].mean()
    std_r = valid["residual"].std()

    fig = go.Figure()
    colors = valid["signal"].map({"CHEAP": "#27ae60", "RICH": "#e74c3c", "NEUTRAL": "#95a5a6", "N/A": "#bdc3c7"})
    fig.add_trace(go.Scatter(x=valid["date"], y=valid["residual"], mode="lines+markers",
                             marker=dict(color=colors, size=5), line=dict(color="#7f8c8d", width=1),
                             name="Residual"))
    # Threshold lines
    fig.add_hline(y=mean_r + cheap_thresh * std_r, line_dash="dash", line_color="#27ae60",
                  annotation_text=f"Cheap ({cheap_thresh}Ïƒ)")
    fig.add_hline(y=mean_r - rich_thresh * std_r, line_dash="dash", line_color="#e74c3c",
                  annotation_text=f"Rich (-{rich_thresh}Ïƒ)")
    fig.add_hline(y=mean_r, line_dash="dot", line_color="gray")
    fig.update_layout(title="Residuals Over Time", xaxis_title="Date", yaxis_title="Residual (%)",
                      template="plotly_white", height=400)
    return fig


def chart_zscore(results, cheap_thresh, rich_thresh):
    valid = results.dropna(subset=["z_score"])
    fig = go.Figure()
    colors = valid["signal"].map({"CHEAP": "#27ae60", "RICH": "#e74c3c", "NEUTRAL": "#95a5a6", "N/A": "#bdc3c7"})
    fig.add_trace(go.Bar(x=valid["date"], y=valid["z_score"],
                         marker_color=colors, name="Z-Score"))
    fig.add_hline(y=cheap_thresh, line_dash="dash", line_color="#27ae60",
                  annotation_text=f"Cheap ({cheap_thresh}Ïƒ)")
    fig.add_hline(y=-rich_thresh, line_dash="dash", line_color="#e74c3c",
                  annotation_text=f"Rich (-{rich_thresh}Ïƒ)")
    fig.add_hline(y=0, line_color="gray", line_width=0.5)
    fig.update_layout(title="Z-Score History", xaxis_title="Date", yaxis_title="Z-Score",
                      template="plotly_white", height=400)
    return fig


def chart_coefficients(model_stats):
    labels = [FEATURE_LABELS.get(c, c) for c in FEATURE_COLS]
    coefs = model_stats["coefficients"]
    colors = ["#27ae60" if c > 0 else "#e74c3c" for c in coefs]
    fig = go.Figure(go.Bar(y=labels, x=coefs, orientation="h",
                           marker_color=colors, text=[f"{c:.4f}" for c in coefs],
                           textposition="outside"))
    fig.update_layout(title="Current Regression Coefficients",
                      xaxis_title="Coefficient Value", template="plotly_white",
                      height=420, margin=dict(l=160))
    return fig


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Excel export
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def generate_excel_report(results, model_stats, raw_df, feat_df, attrib_df):
    """Generate a multi-sheet Excel workbook."""
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, PatternFill, Alignment, numbers, Border, Side
        from openpyxl.utils.dataframe import dataframe_to_rows
    except ImportError:
        st.error("openpyxl not installed.")
        return None

    wb = Workbook()

    header_font = Font(bold=True, color="FFFFFF", size=11)
    header_fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
    green_fill = PatternFill(start_color="27AE60", end_color="27AE60", fill_type="solid")
    red_fill = PatternFill(start_color="E74C3C", end_color="E74C3C", fill_type="solid")
    gray_fill = PatternFill(start_color="95A5A6", end_color="95A5A6", fill_type="solid")
    thin_border = Border(
        left=Side(style='thin'), right=Side(style='thin'),
        top=Side(style='thin'), bottom=Side(style='thin')
    )

    def _style_header(ws, ncols):
        for col in range(1, ncols + 1):
            cell = ws.cell(row=1, column=col)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = Alignment(horizontal="center")
            cell.border = thin_border

    def _auto_width(ws):
        from openpyxl.utils import get_column_letter
        for col_idx in range(1, ws.max_column + 1):
            max_len = 0
            for row_idx in range(1, ws.max_row + 1):
                cell = ws.cell(row=row_idx, column=col_idx)
                try:
                    max_len = max(max_len, len(str(cell.value or "")))
                except:
                    pass
            col_letter = get_column_letter(col_idx)
            ws.column_dimensions[col_letter].width = min(max_len + 3, 30)

    # --- Sheet 1: Dashboard ---
    ws = wb.active
    ws.title = "Dashboard"
    latest = results.dropna(subset=["z_score"]).iloc[-1]
    ws.append(["HY Spread Rich/Cheap Model â€” Dashboard"])
    ws.merge_cells("A1:D1")
    ws["A1"].font = Font(bold=True, size=16)
    ws.append([])
    ws.append(["Generated", datetime.now().strftime("%Y-%m-%d %H:%M")])
    ws.append(["Latest Data Date", latest["date"].strftime("%Y-%m-%d")])
    ws.append([])
    ws.append(["CURRENT SIGNAL", latest["signal"]])
    sig_cell = ws.cell(row=6, column=2)
    sig_cell.font = Font(bold=True, color="FFFFFF", size=14)
    if latest["signal"] == "CHEAP":
        sig_cell.fill = green_fill
    elif latest["signal"] == "RICH":
        sig_cell.fill = red_fill
    else:
        sig_cell.fill = gray_fill
    ws.append([])
    ws.append(["Metric", "Value"])
    metrics = [
        ("Actual HY Spread", f"{latest['hy_spread']:.2f}%"),
        ("Predicted HY Spread", f"{latest['predicted']:.2f}%"),
        ("Residual", f"{latest['residual']:.2f}%"),
        ("Z-Score", f"{latest['z_score']:.2f}"),
        ("RÂ²", f"{model_stats['r2']:.4f}"),
        ("Adj RÂ²", f"{model_stats['adj_r2']:.4f}"),
    ]
    for label, val in metrics:
        ws.append([label, val])
    _auto_width(ws)

    # --- Sheet 2: Data Input ---
    ws2 = wb.create_sheet("Data Input")
    raw_export = raw_df.copy()
    raw_export["date"] = raw_export["date"].dt.strftime("%Y-%m-%d")
    for r in dataframe_to_rows(raw_export, index=False, header=True):
        ws2.append(r)
    _style_header(ws2, len(raw_export.columns))
    _auto_width(ws2)

    # --- Sheet 3: Calculated Features ---
    ws3 = wb.create_sheet("Calculated Features")
    feat_export = feat_df.copy()
    feat_export["date"] = feat_export["date"].dt.strftime("%Y-%m-%d")
    for r in dataframe_to_rows(feat_export, index=False, header=True):
        ws3.append(r)
    _style_header(ws3, len(feat_export.columns))
    _auto_width(ws3)

    # --- Sheet 4: Model Statistics ---
    ws4 = wb.create_sheet("Model Statistics")
    ws4.append(["Feature", "Coefficient", "Std Error", "T-Statistic", "P-Value"])
    _style_header(ws4, 5)
    for i, col in enumerate(FEATURE_COLS):
        ws4.append([
            FEATURE_LABELS.get(col, col),
            round(model_stats["coefficients"][i], 6),
            round(model_stats["std_errors"][i], 6),
            round(model_stats["t_stats"][i], 4),
            round(model_stats["p_values"][i], 6),
        ])
    ws4.append([])
    ws4.append(["Intercept", round(model_stats["intercept"], 6)])
    ws4.append(["RÂ²", round(model_stats["r2"], 6)])
    ws4.append(["Adjusted RÂ²", round(model_stats["adj_r2"], 6)])
    ws4.append(["Observations", model_stats["n_obs"]])
    ws4.append(["Residual Std Dev", round(model_stats["residual_std"], 6)])
    _auto_width(ws4)

    # --- Sheet 5: Historical Signals ---
    ws5 = wb.create_sheet("Historical Signals")
    hist = results.dropna(subset=["predicted"])[["date", "hy_spread", "predicted", "residual", "z_score", "signal"]].copy()
    hist["date"] = hist["date"].dt.strftime("%Y-%m-%d")
    hist.columns = ["Date", "HY Spread", "Predicted", "Residual", "Z-Score", "Signal"]
    for r in dataframe_to_rows(hist, index=False, header=True):
        ws5.append(r)
    _style_header(ws5, 6)
    for row in range(2, ws5.max_row + 1):
        sig = ws5.cell(row=row, column=6).value
        if sig == "CHEAP":
            ws5.cell(row=row, column=6).fill = PatternFill(start_color="C8E6C9", fill_type="solid")
        elif sig == "RICH":
            ws5.cell(row=row, column=6).fill = PatternFill(start_color="FFCDD2", fill_type="solid")
    _auto_width(ws5)

    # --- Sheet 6: Instructions ---
    ws6 = wb.create_sheet("Instructions")
    instructions = [
        ["How to Interpret This Model"],
        [""],
        ["This model uses rolling multiple linear regression to predict US High Yield spreads"],
        ["based on market fundamentals (VIX, Oil, CDX, MOVE, SPX, HYG flows)."],
        [""],
        ["Key Concepts:"],
        ["- Predicted Spread: the model's 'fair value' estimate for HY spreads"],
        ["- Residual: Actual minus Predicted (positive = wider than expected)"],
        ["- Z-Score: standardized residual (how many standard deviations from average)"],
        [""],
        ["Signals:"],
        ["- CHEAP: Z-Score above the cheap threshold â€” spreads are wider than expected"],
        ["  (potential buying opportunity)"],
        ["- RICH: Z-Score below the negative rich threshold â€” spreads are tighter than expected"],
        ["  (potential selling/hedging opportunity)"],
        ["- NEUTRAL: Z-Score between thresholds â€” no strong signal"],
        [""],
        ["Asymmetric Thresholds:"],
        ["The model uses different thresholds for RICH vs CHEAP because selling HY bonds"],
        ["means giving up carry income (4-6% per year). A stronger signal is required to"],
        ["justify selling (RICH) compared to buying (CHEAP)."],
    ]
    for row in instructions:
        ws6.append(row)
    ws6["A1"].font = Font(bold=True, size=14)
    _auto_width(ws6)

    buf = io.BytesIO()
    wb.save(buf)
    buf.seek(0)
    return buf


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Streamlit App
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    # â”€â”€ Sidebar â”€â”€
    st.sidebar.image("https://img.icons8.com/color/96/combo-chart.png", width=60)
    st.sidebar.title("HY Rich/Cheap Model")
    st.sidebar.markdown("---")

    uploaded_file = st.sidebar.file_uploader(
        "ğŸ“ Upload Excel Data",
        type=["xlsx"],
        help="Upload a .xlsx file with monthly data: Date, HY Spread, VIX, Oil, CDX, MOVE, SPX Yield, HYG Shares."
    )

    st.sidebar.markdown("### âš™ï¸ Model Settings")
    lookback = st.sidebar.select_slider(
        "Lookback Period (months)",
        options=[36, 48, 60],
        value=60,
        help="Number of months used in the rolling regression window."
    )
    cheap_thresh = st.sidebar.slider(
        "Cheap Threshold (Ïƒ)", 0.5, 2.0, 1.0, 0.1,
        help="Z-score above this â†’ CHEAP signal (buy). Lower = more sensitive."
    )
    rich_thresh = st.sidebar.slider(
        "Rich Threshold (Ïƒ)", 1.0, 3.0, 2.0, 0.1,
        help="Z-score below negative of this â†’ RICH signal (sell). Higher = stronger conviction required."
    )

    st.sidebar.markdown("---")
    st.sidebar.markdown("""
    **Why asymmetric thresholds?**
    Selling HY bonds loses carry income (4-6%/yr).
    A stronger signal is needed to sell than to buy.
    """)

    # â”€â”€ Main Panel â”€â”€
    st.title("ğŸ“Š US High Yield Spread â€” Rich/Cheap Model")

    if uploaded_file is None:
        st.info("ğŸ‘ˆ Upload your Excel data file in the sidebar to get started.")
        with st.expander("â„¹ï¸ About This Model"):
            st.markdown("""
            This tool runs a **rolling multiple linear regression** to estimate the "fair value"
            of US High Yield credit spreads based on six market factors:

            **VIX** (equity volatility), **Oil** prices, **CDX HY** (credit derivatives),
            **MOVE** (bond volatility), **S&P 500** (risk appetite), and **HYG ETF flows** (fund positioning).

            When actual spreads deviate significantly from the model's prediction, a **CHEAP**
            (buy) or **RICH** (sell/hedge) signal is generated using asymmetric z-score thresholds.
            """)
        return

    # Load data
    raw_df, col_map = load_data(uploaded_file)
    if raw_df is None:
        return

    # Feature engineering
    feat_df = engineer_features(raw_df)

    if len(feat_df) < lookback + 5:
        st.error(f"Not enough data ({len(feat_df)} rows after feature engineering) for {lookback}-month lookback.")
        return

    # Run model
    with st.spinner("Running rolling regression..."):
        reg_result = run_regression(feat_df, lookback)

    if reg_result is None or reg_result[0] is None:
        return

    results, model_stats, coef_df = reg_result
    results = calculate_signals(results, cheap_thresh, rich_thresh)

    # â”€â”€ Section 1: Current Signal â”€â”€
    latest = results.dropna(subset=["z_score"]).iloc[-1]
    prev_rows = results.dropna(subset=["z_score"])
    prev_signal = prev_rows.iloc[-2]["signal"] if len(prev_rows) >= 2 else "N/A"

    signal = latest["signal"]
    css_class = {"CHEAP": "signal-cheap", "RICH": "signal-rich"}.get(signal, "signal-neutral")
    st.markdown(f"""
    <div class="signal-box {css_class}">
        <div style="font-size:14px; opacity:0.85;">Current Signal as of {latest['date'].strftime('%B %d, %Y')}</div>
        <div style="font-size:42px; margin:8px 0;">{signal}</div>
        <div style="font-size:18px;">Z-Score: {latest['z_score']:.2f}</div>
    </div>
    """, unsafe_allow_html=True)

    # â”€â”€ Section 2: Key Metrics â”€â”€
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Actual HY Spread", f"{latest['hy_spread']:.2f}%")
    col2.metric("Predicted Spread", f"{latest['predicted']:.2f}%")
    col3.metric("Residual", f"{latest['residual']:+.2f}%")
    col4.metric("Model RÂ²", f"{model_stats['r2']:.3f}")

    col5, col6, col7, col8 = st.columns(4)
    col5.metric("Z-Score", f"{latest['z_score']:+.2f}")
    col6.metric("Signal", signal)
    col7.metric("Previous Signal", prev_signal)
    col8.metric("Adj. RÂ²", f"{model_stats['adj_r2']:.3f}")

    st.markdown("---")

    # â”€â”€ Section 3: Charts â”€â”€
    st.subheader("ğŸ“ˆ Interactive Charts")

    tab1, tab2, tab3, tab4 = st.tabs([
        "Actual vs Predicted", "Residuals", "Z-Score History", "Factor Coefficients"
    ])

    with tab1:
        st.plotly_chart(chart_actual_vs_predicted(results), use_container_width=True)
    with tab2:
        st.plotly_chart(chart_residuals(results, cheap_thresh, rich_thresh), use_container_width=True)
    with tab3:
        st.plotly_chart(chart_zscore(results, cheap_thresh, rich_thresh), use_container_width=True)
    with tab4:
        st.plotly_chart(chart_coefficients(model_stats), use_container_width=True)

    st.markdown("---")

    # â”€â”€ Section 4: Monthly Attribution â”€â”€
    with st.expander("ğŸ” Monthly Attribution Analysis", expanded=False):
        attrib = monthly_attribution(results, coef_df)
        if attrib is not None:
            st.dataframe(
                attrib.style.format({
                    "Coefficient": "{:.6f}",
                    "Feature Change": "{:.4f}",
                    "Contribution (spread, %)": "{:+.4f}",
                    "% of Total": "{:+.1f}%",
                }),
                use_container_width=True,
            )
        else:
            st.info("Not enough data points for attribution analysis.")

    # â”€â”€ Section 5: Regression Statistics â”€â”€
    with st.expander("ğŸ“‹ Regression Statistics", expanded=False):
        stats_df = pd.DataFrame({
            "Feature": [FEATURE_LABELS.get(c, c) for c in FEATURE_COLS],
            "Coefficient": model_stats["coefficients"],
            "Std Error": model_stats["std_errors"],
            "T-Statistic": model_stats["t_stats"],
            "P-Value": model_stats["p_values"],
        })
        st.dataframe(
            stats_df.style.format({
                "Coefficient": "{:.6f}",
                "Std Error": "{:.6f}",
                "T-Statistic": "{:.3f}",
                "P-Value": "{:.4f}",
            }).apply(lambda x: ["background-color: #fff3cd" if v < 0.05 else "" for v in x], subset=["P-Value"]),
            use_container_width=True,
        )

        c1, c2, c3, c4 = st.columns(4)
        c1.metric("Intercept", f"{model_stats['intercept']:.4f}")
        c2.metric("RÂ²", f"{model_stats['r2']:.4f}")
        c3.metric("Adj. RÂ²", f"{model_stats['adj_r2']:.4f}")
        c4.metric("Residual Std", f"{model_stats['residual_std']:.4f}")

    # â”€â”€ Section 6: Historical Signals â”€â”€
    with st.expander("ğŸ“… Historical Signals Table", expanded=False):
        hist = results.dropna(subset=["predicted"])[["date", "hy_spread", "predicted", "residual", "z_score", "signal"]].copy()
        hist.columns = ["Date", "HY Spread", "Predicted", "Residual", "Z-Score", "Signal"]

        def _color_signal(val):
            if val == "CHEAP":
                return "background-color: #c8e6c9; color: #1b5e20;"
            elif val == "RICH":
                return "background-color: #ffcdd2; color: #b71c1c;"
            return ""

        st.dataframe(
            hist.style.format({
                "Date": lambda x: x.strftime("%Y-%m-%d"),
                "HY Spread": "{:.2f}",
                "Predicted": "{:.2f}",
                "Residual": "{:+.3f}",
                "Z-Score": "{:+.2f}",
            }).map(_color_signal, subset=["Signal"]),
            use_container_width=True,
            height=400,
        )

    # â”€â”€ Excel Download â”€â”€
    st.markdown("---")
    attrib = monthly_attribution(results, coef_df)
    excel_buf = generate_excel_report(results, model_stats, raw_df, feat_df, attrib)
    if excel_buf:
        st.download_button(
            "ğŸ“¥ Download Excel Report",
            data=excel_buf,
            file_name=f"HY_RichCheap_Report_{datetime.now().strftime('%Y%m%d')}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.ml.sheet",
        )


if __name__ == "__main__":
    main()
